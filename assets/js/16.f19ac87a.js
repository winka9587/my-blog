(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{474:function(t,e,s){t.exports=s.p+"assets/img/20190506135906249.6e300c7d.jpg"},475:function(t,e,s){t.exports=s.p+"assets/img/20190506140629478.08aef5e4.jpg"},476:function(t,e,s){t.exports=s.p+"assets/img/20190506140640837.5ad1ff9f.jpg"},477:function(t,e,s){t.exports=s.p+"assets/img/20190506141249586.981cf30a.jpg"},571:function(t,e,s){"use strict";s.r(e);var r=s(56),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"opengl通过glrasterpos设置当前光栅坐标实现分屏效果"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#opengl通过glrasterpos设置当前光栅坐标实现分屏效果"}},[t._v("#")]),t._v(" openGL通过glRasterPos设置当前光栅坐标实现分屏效果")]),t._v(" "),r("p",[t._v("最近做一个分屏效果，即左右两个viewport同时显示一个bmp图像")]),t._v(" "),r("p",[r("img",{attrs:{src:s(474),alt:"img"}}),t._v(" 最终效果")]),t._v(" "),r("p",[t._v("我的bmp图像是从摄像头获得的，摄像头的画面是先保存成bmp文件，再使用glDrawPixel绘制出来的，绘制一个还行，但是绘制第二个（即右边的）的时候就遇到了问题，怎样改变glDrawPixel绘制图像的位置？")]),t._v(" "),r("p",[t._v("glDrawPixel不像glBitmap可以直接指定绘制起点，注意windows下的bmp文件算是图片，并不算是位图，要绘制bmp文件并不能用glBitmap函数")]),t._v(" "),r("p",[r("img",{attrs:{src:s(475),alt:"img"}}),r("img",{attrs:{src:"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==",alt:"点击并拖拽以移动"}}),r("img",{attrs:{src:s(476),alt:"img"}}),r("img",{attrs:{src:"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==",alt:"点击并拖拽以移动"}})]),t._v(" "),r("p",[t._v("来自")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://docs.microsoft.com/zh-cn/windows/desktop/OpenGL/gldrawpixels",target:"_blank",rel:"noopener noreferrer"}},[t._v("glDrawPixels 函数 (Gl) - Win32 apps | Microsoft Docs"),r("OutboundLink")],1)]),t._v(" "),r("p",[r("a",{attrs:{href:"https://docs.microsoft.com/zh-cn/windows/desktop/OpenGL/glbitmap",target:"_blank",rel:"noopener noreferrer"}},[t._v("glBitmap 函数 (Gl.h) - Win32 apps | Microsoft Docs"),r("OutboundLink")],1)]),t._v(" "),r("blockquote",[r("p",[r("strong",[t._v("glDrawPixels")]),t._v(" function reads pixel data from memory and writes it into the framebuffer relative to the current raster position")])]),t._v(" "),r("p",[t._v("glDrawPixel从内存中读取像素数据并写入帧缓存，受到当前光栅坐标的影响。当前光栅坐标包括四部分（x,y,z,w），其中w与裁剪相关，可以通过glGet的GL_CURRENT_RASTER_POSITION参数来获得当前光栅坐标，默认为（0,0,0,1）")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('float pos[4];\nglGetFloatv(GL_CURRENT_RASTER_POSITION, pos);\nprintf("x:%f\\n", pos[0]);\nprintf("y:%f\\n", pos[1]);\nprintf("z:%f\\n", pos[2]);\nprintf("w:%f\\n", pos[3]);![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n')])])]),r("p",[t._v("默认的绘制起点是屏幕的左下角，通过glRasterPos方法可以改变当前光栅坐标从而改变glDrawPixel的绘制起始位置。")]),t._v(" "),r("p",[t._v("glRasterPos有许多分支，它们都用来指定当前光栅坐标")]),t._v(" "),r("p",[r("img",{attrs:{src:s(477),alt:"img"}}),r("img",{attrs:{src:"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==",alt:"点击并拖拽以移动"}})]),t._v(" "),r("p",[t._v("glRasterPos2f与glRasterPos3f的区别在于")]),t._v(" "),r("p",[t._v("glRasterPos2f只改变x,y，将z，w设置为0和1")]),t._v(" "),r("p",[t._v("glRasterPosz,w，3f改变x,y,z，将w设置为1")]),t._v(" "),r("p",[t._v("同理，4f是改变xyzw")]),t._v(" "),r("h2",{attrs:{id:"glrasterpos的参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#glrasterpos的参数"}},[t._v("#")]),t._v(" glRasterPos的参数")]),t._v(" "),r("p",[t._v("我在改变光栅坐标时遇到了一个问题，无论如何通过glRasterPos设置坐标，glGet返回的结果只有w的值发生了改变，xyz始终为0，而且也没有图像被绘制出来。")]),t._v(" "),r("p",[t._v("出现这个问题的原因在于：")]),t._v(" "),r("p",[t._v("glRasterPos设置的坐标是世界坐标，受到投影变换和视景体裁剪的影响，也就是说我设置的世界坐标在经过ModelView，Projection，和ViewPort的变换之后，如果没有在视景体之内（你可以理解为camera看不见），那么这个坐标是无效的，无法改变glRasterPos的xyz，glDrawPixel也不会进行绘制")]),t._v(" "),r("p",[t._v("你可以通过glGet的GL_CURRENT_RASTER_POSITION_VALID参数来检查当前光栅坐标是否有效")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("GLboolean if_valid;\nglGetBooleanv(GL_CURRENT_RASTER_POSITION_VALID, &if_valid);\n")])])]),r("p",[t._v("如果返回的是false，那么恭喜你设置的坐标确实有问题。")]),t._v(" "),r("p",[t._v("我的投影矩阵和模型视图矩阵变换非常复杂，怎么样才能找到正确的参数？")]),t._v(" "),r("p",[t._v("两种解决办法：")]),t._v(" "),r("p",[t._v("1、glWindowPos函数允许你通过设置屏幕坐标来改变光栅坐标，但需要引入glew库")]),t._v(" "),r("p",[t._v("2、通过glUnProject计算出屏幕坐标对应的世界坐标")]),t._v(" "),r("p",[t._v("我使用的是第二种方法，第一种方法没有试验过，两种方法的本质其实都是一样的")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('GLdouble world_x, world_y, world_z;//最终结果\n\n//计算屏幕坐标对应的世界坐标\nvoid GetPos() {\n\t\tGLdouble screen_x, screen_y, screen_z;\n\t\tGLdouble m_projection[16], m_modelview[16];\n\t\tGLint m_viewport[4];\n\t\tglGetDoublev(GL_PROJECTION_MATRIX, m_projection);//获得投影矩阵\n\t\tglGetDoublev(GL_MODELVIEW_MATRIX, m_modelview);//获得模型视图矩阵\n\t\tglGetIntegerv(GL_VIEWPORT, m_viewport);//获得viewport\n\t\t\n        //设置屏幕坐标的x,y\n        screen_x = imagewidth;//imagewidth是一张bmp图片的宽度\n\t\tscreen_y= 0;\n\t\tscreen_z = 0;\n\n        //获得对应的世界坐标\n\t\tgluUnProject((GLdouble)screen_x, (GLdouble)screen_y, (GLdouble)screen_z, m_modelview, m_projection, m_viewport, &world_x, &world_y, &world_z);\n\n\t\t\n\t\tcout << "得到的world坐标：" << endl;\n\t\tcout << "（" << world_x << "，" << world_y << "，" << world_z << "）" << endl;\n}\n')])])]),r("p",[t._v("在gluUnProject中进行（GLdouble）的强制类型转换是出于精度的考虑，因为看到一些博客说如果不是GLdouble类型使用float的话会导致出现误差。")]),t._v(" "),r("p",[t._v("注意在绘制完右边的图像后再想绘制坐标的图像需要将当前光栅坐标改回去，再使用上面的函数计算一次，屏幕坐标x和y要改为0,0（屏幕坐标系原点在左下角），如果是想在鼠标函数中实现某些效果，要记得对y坐标进行处理转为屏幕坐标")])])}),[],!1,null,null,null);e.default=a.exports}}]);