(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{420:function(t,n,e){t.exports=e.p+"assets/img/20190529170027837.3d7543cf.gif"},421:function(t,n,e){t.exports=e.p+"assets/img/20190529165803826.0176305d.gif"},422:function(t,n,e){t.exports=e.p+"assets/img/20190528130456475.8559e7b8.jpg"},423:function(t,n,e){t.exports=e.p+"assets/img/image-20220314202746181.f2606fe8.png"},424:function(t,n,e){t.exports=e.p+"assets/img/image-20220314202825524.c586f550.png"},425:function(t,n,e){t.exports=e.p+"assets/img/image-20220314203039336.fb2ad177.png"},426:function(t,n,e){t.exports=e.p+"assets/img/image-20220314203053474.76184cbc.png"},427:function(t,n,e){t.exports=e.p+"assets/img/image-20220314203118145.58103c17.png"},428:function(t,n,e){t.exports=e.p+"assets/img/image-20220314203108318.a8923801.png"},429:function(t,n,e){t.exports=e.p+"assets/img/image-20220314203137213.7cf8d3ba.png"},430:function(t,n,e){t.exports=e.p+"assets/img/image-20220314203211953.b41ab4fb.png"},431:function(t,n,e){t.exports=e.p+"assets/img/image-20220314203222898.381db029.png"},566:function(t,n,e){"use strict";e.r(n);var a=e(56),v=Object(a.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"opengl使用laplacian进行网格光顺"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#opengl使用laplacian进行网格光顺"}},[t._v("#")]),t._v(" OpenGL使用Laplacian进行网格光顺")]),t._v(" "),a("p",[t._v("题目要求使用OpenGL+Laplacian算子对obj文件进行网格光顺，这篇算是作业的记录吧")]),t._v(" "),a("p",[t._v("什么是网格光顺？网格光顺在不改变顶点之间连接关系、减小曲率变化的前提下移动顶点，达到减小噪声、改善网格三角形形状的效果。该善三角形形状->趋向于正三角形，你可以观察下面的三角形网格变化。")]),t._v(" "),a("p",[t._v("先用gif图演示一下网格光顺的效果，直观感受一下")]),t._v(" "),a("p",[a("img",{attrs:{src:e(420),alt:"20190529170027837"}}),a("img",{attrs:{src:e(421),alt:"20190529165803826"}})]),t._v(" "),a("p",[t._v("上一次接触Laplacian"),a("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E7%AE%97%E5%AD%90&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("算子"),a("OutboundLink")],1),t._v("还是在数字图像处理的课程上，使用Laplacian算子处理图像来获得边缘增强的图像，再与原来的图像进行结合，实现图像的锐化。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(422),alt:"20190528130456475"}})]),t._v(" "),a("h2",{attrs:{id:"obj文件的数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#obj文件的数据结构"}},[t._v("#")]),t._v(" obj文件的数据结构")]),t._v(" "),a("p",[t._v("开始先使用MeshLab看看我们要处理的obj文件")]),t._v(" "),a("p",[a("img",{attrs:{src:e(423),alt:"image-20220314202746181"}})]),t._v(" "),a("p",[t._v("经典小兔，搞图形学的都不陌生。用记事本打开obj文件可以看到这个obj文件里面只有")]),t._v(" "),a("p",[t._v("v：几何体顶点（Geometry Vertice）")]),t._v(" "),a("p",[t._v("vn：顶点法线（Vertex Normal）")]),t._v(" "),a("p",[t._v("f：面（Face）")]),t._v(" "),a("p",[t._v("三种数据")]),t._v(" "),a("p",[t._v("截取部分：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(424),alt:"image-20220314202825524"}})]),t._v(" "),a("p",[t._v("其中v和vn后面跟的都是xyz")]),t._v(" "),a("p",[t._v("usemtl(null)表示没有贴图")]),t._v(" "),a("p",[t._v("面f的数据格式是")]),t._v(" "),a("p",[t._v("f 顶点索引//顶点法向索引  顶点索引//顶点法向索引  顶点索引//顶点法向索引")]),t._v(" "),a("p",[t._v("比如 “f 1//4 2//5 3//6” 就是这个面由第1、2、3个点构成，这三个顶点又分别对应第4、5、6个顶点法向")]),t._v(" "),a("p",[t._v("（如果有贴图的话就是  顶点索引/纹理索引/顶点法向索引）")]),t._v(" "),a("p",[t._v("注意，obj文件的索引都是从1开始的而不是0")]),t._v(" "),a("p",[t._v("读取obj文件\n代码参考了这位博主的代码：非常简单，教你用OpenGL读入obj模型_旧时光 | YoungChen's 博客-CSDN博客")]),t._v(" "),a("p",[t._v("在其基础上进行了改进：")]),t._v(" "),a("p",[t._v("1、原po的顶点法向是计算出来的，而我们的obj文件中已经有顶点法向的数据，添加了读取顶点法向的操作")]),t._v(" "),a("p",[t._v("2、同时存储顶点xyz坐标的vset中还记录了包含该顶点的face，将face索引存入顶点的vector中是为了便于之后Laplacian的相关计算，我不知道obj文件的顶点之间是否有什么特殊的排列或者什么办法能够快速地找到周围的点。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('objLoader::objLoader(string filename)\n{\n\tdrawmode = GL_LINE;//默认是绘制轮廓\n\tstring line;//读取每一行\n\tfstream f;\n\tf.open(filename, ios::in);//读文件\n\tif (!f.is_open()) {\n\t\tcout << "file cannot open" << endl;\n\t}\n\telse {\n\t\tcout << "file open successful" << endl;\n\t}\n\n\twhile (!f.eof()) {\n\t\tgetline(f, line);\n\t\tchar breakmarker = \' \';//obj中每行各部分以空格隔开\n\t\tstring little_tail = " ";\n\t\tline = line.append(little_tail);//为line末尾添加一个分隔符\n\t\t//将当前行根据空格分开\n\t\tstring part = "";\n\t\tvector<string> partofline;//当前行根据空格拆分成的各个string部分\n\t\tfor (int i = 0; i < line.length(); i++) {\n\t\t\tchar nowchar = line[i];\n\t\t\tif (nowchar == breakmarker) {\n\t\t\t\t//如果当前char为空格，将前面的部分存入partofline\n\t\t\t\tpartofline.push_back(part);\n\t\t\t\tpart = "";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpart += nowchar;\n\t\t\t}\n\t\t}\n\t\t//当前行拆分完毕\n\t\t//根据不同的数据进行相应操作\n\t\tif (partofline.size() == 4) {\n\t\t\t//我们的网格是三角形网格，如果不是拆分成4部分那就没必要检查\n\t\t\tif (partofline[0] == "v") {\n\t\t\t\t//当前行是顶点，存储顶点坐标\n\t\t\t\tvector<GLdouble> v;\n\t\t\t\tfor (int n = 1; n < 4; n++) {\n\t\t\t\t\t//GLdouble xyz = atof(partofline[n].c_str());//转换成double\n\t\t\t\t\tGLdouble xyz = atof(partofline[n].c_str());//转换成double\n\t\t\t\t\tv.push_back(xyz);\n\t\t\t\t}\n\t\t\t\tvset.push_back(v);\n\t\t\t}\n\t\t\tif (partofline[0] == "vn") {\n\t\t\t\t//当前行是顶点向量，存储向量\n\t\t\t\tvector<GLdouble> vn;\n\t\t\t\tfor (int n = 1; n < 4; n++) {\n\t\t\t\t\t//GLdouble xyz = atof(partofline[n].c_str());//转换成double\n\t\t\t\t\tGLdouble xyz = atof(partofline[n].c_str());//转换成double\n\t\t\t\t\tvn.push_back(xyz);\n\t\t\t\t}\n\t\t\t\tvnset.push_back(vn);\n\t\t\t}\n\t\t\t\n\t\t\tif (partofline[0] == "f") {\n\t\t\t\t//当前行是面，将顶点索引和对应的顶点法向索引存储起来\n\t\t\t\t//因为在执行到面的时候所有顶点已经存储完成，将顶点对应的面存储到顶点中\n\t\t\t\tvector<GLint> f;\n\t\t\t\t//因为数据格式是  顶点索引//顶点法向索引\n\t\t\t\t//要将中间两道斜线去掉\n\t\t\t\tfor (int n = 1; n < 4; n++) {//处理三个v//vn\n\t\t\t\t\tvector<string> vvn;//存放处理好的v和vn\n\t\t\t\t\tstring v_and_vn = partofline[n];// v//vn\n\t\t\t\t\tv_and_vn = v_and_vn.append("/");\n\t\t\t\t\tstring part = "";\n\t\t\t\t\tfor (int c = 0; c < v_and_vn.length(); c++) {//将v//vn拆开\n\t\t\t\t\t\tchar nowcharofpart = v_and_vn[c];\n\t\t\t\t\t\t//因为2个/，vvn[0]存储v,vvn[1]存储""，vvn[2]存储vn\n\t\t\t\t\t\tif (nowcharofpart == \'/\') {\n\t\t\t\t\t\t\tvvn.push_back(part);\n\t\t\t\t\t\t\tpart = "";\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpart += nowcharofpart;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//v和vn已经拆分好并存入了vvn，现在存入对应的set\n\t\t\t\t\tGLint vindex = atof(vvn[0].c_str());\n\t\t\t\t\tGLint vnindex = atof(vvn[2].c_str());\n\t\t\t\t\t//f的结构为 { v0 , vn0 , v1 , vn1 , v2 , vn2 }\n\t\t\t\t\tf.push_back(vindex);\n\t\t\t\t\tf.push_back(vnindex);\n\t\t\t\t\t//cout << "v:" << vindex << endl;\n\t\t\t\t\t//cout << "vn:" << vnindex << endl;\n\t\t\t\t\t//既然已经知道了顶点索引，将面索引存入到对应的顶点中去\n\t\t\t\t\t//obj文件的索引是从1开始的而不是0\n\t\t\t\t\t//这时候f还没有添加到fset中去，f的序号(从0开始)应该为fset.size()\n\t\t\t\t\tvset[vindex - 1].push_back(fset.size());\n\t\t\t\t\t//cout << "face number:" << fset.size()<<endl;\n\t\t\t\t}\n\n\t\t\t\tfset.push_back(f);//将顶点索引和顶点向量索引存入fset\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//输出当前行的初步拆分结果\n\t\tcout<<"line：" << line << endl;\n\t\tcout << "part number：" << partofline.size()<<endl;\n\t\tfor (int j = 0; j < partofline.size(); j++) {\n\t\t\tcout << partofline[j] << endl;\n\t\t}\n\t\t*/\n\t}\n\n\tvset_begin.assign(vset.begin(), vset.end());//将vset备份\n\tf.close();\n\t/*\n\t//输出最终结果\n\tcout << "输出vset" << endl;\n\tfor (int m = 0; m < vset.size(); m++) {\n\t\tfor (int n = 0; n < vset[m].size(); n++) {\n\t\t\tcout << vset[m][n] << "，";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << "输出vnset" << endl;\n\tfor (int m = 0; m < vnset.size(); m++) {\n\t\tfor (int n = 0; n < vnset[m].size(); n++) {\n\t\t\tcout << vnset[m][n] << "，";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << "输出fset" << endl;\n\tfor (int m = 0; m < fset.size(); m++) {\n\t\tfor (int n = 0; n < fset[m].size(); n++) {\n\t\t\tcout << fset[m][n] << "，";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n}\n')])])]),a("h2",{attrs:{id:"绘制模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绘制模型"}},[t._v("#")]),t._v(" 绘制模型")]),t._v(" "),a("p",[t._v("glNormal和glVertex将读取到的顶点法向与对应的顶点绑定")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("void objLoader::drawobj() {\n\tint vindex1, vindex2, vindex3,\n\t\tvnindex1,vnindex2,vnindex3;\n\t\tglPolygonMode(GL_FRONT_AND_BACK, drawmode);\n\t\tfor (int i = 0; i < fset.size(); i++) {\n\t\t\t//索引从1开始，set从0开始\n\t\t\t//顶点索引\n\t\t\tvindex1 = fset[i][0] - 1;\n\t\t\tvindex2 = fset[i][2] - 1;\n\t\t\tvindex3 = fset[i][4] - 1;\n\t\t\t//顶点法向索引\n\t\t\tvnindex1 = fset[i][1] - 1;\n\t\t\tvnindex2 = fset[i][3] - 1;\n\t\t\tvnindex3 = fset[i][5] - 1;\n\t\t\tglBegin(GL_TRIANGLES);\n\t\t\tif (reverseVertexNormal) {\n\t\t\t\tglNormal3d(-vnset[vnindex1][0], -vnset[vnindex1][1], -vnset[vnindex1][2]);//设置顶点法向\n\t\t\t\tglVertex3d(vset[vindex1][0], vset[vindex1][1], vset[vindex1][2]);\n\t\t\t\tglNormal3d(-vnset[vnindex2][0], -vnset[vnindex2][1], -vnset[vnindex2][2]);\n\t\t\t\tglVertex3d(vset[vindex2][0], vset[vindex2][1], vset[vindex2][2]);\n\t\t\t\tglNormal3d(-vnset[vnindex3][0], -vnset[vnindex3][1], -vnset[vnindex3][2]);\n\t\t\t\tglVertex3d(vset[vindex3][0], vset[vindex3][1], vset[vindex3][2]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tglNormal3d(vnset[vnindex1][0], vnset[vnindex1][1], vnset[vnindex1][2]);//设置顶点法向\n\t\t\t\tglVertex3d(vset[vindex1][0], vset[vindex1][1], vset[vindex1][2]);\n\t\t\t\tglNormal3d(vnset[vnindex2][0], vnset[vnindex2][1], vnset[vnindex2][2]);\n\t\t\t\tglVertex3d(vset[vindex2][0], vset[vindex2][1], vset[vindex2][2]);\n\t\t\t\tglNormal3d(vnset[vnindex3][0], vnset[vnindex3][1], vnset[vnindex3][2]);\n\t\t\t\tglVertex3d(vset[vindex3][0], vset[vindex3][1], vset[vindex3][2]);\n\t\t\t}\n\t\t\tglEnd();\n\t\t}\n\t\n}\n")])])]),a("p",[a("img",{attrs:{src:"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==",alt:"点击并拖拽以移动"}}),t._v("glPolygonMode()的第二个参数通过在GL_LINE和GL_FILL切换可以达到不同的绘制效果，左为GL_LINE，右为GL_FILL")]),t._v(" "),a("p",[a("img",{attrs:{src:e(425),alt:"image-20220314203039336"}}),a("img",{attrs:{src:e(426),alt:"image-20220314203053474"}})]),t._v(" "),a("p",[t._v("题外话：这里面的reverseVertexNormal是我自己加的一个布尔量，因为这里的顶点法向是从文件中读取的，如果是自己计算顶点法向有可能得到的结果与实际结果相反。于是我就想试试如果把顶点法向反过来会是什么样子，试验结果也贴一下：")]),t._v(" "),a("p",[t._v("为了使看到的模型有亮有暗我调整了一下光源的位置，且环境光几乎为0，demo中应该看不到这样明显的效果，可能需要手动调整一下光源位置并关闭环境光")]),t._v(" "),a("p",[a("img",{attrs:{src:e(427),alt:"image-20220314203118145"}})]),t._v(" "),a("p",[a("img",{attrs:{src:e(428),alt:"image-20220314203108318"}})]),t._v(" "),a("p",[t._v("左为原顶点法向的模型，右为将顶点法向变为相反方向之后的模型，可以看到原来亮的部分变暗了，暗的部分变亮了。")]),t._v(" "),a("h2",{attrs:{id:"laplacian光顺"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#laplacian光顺"}},[t._v("#")]),t._v(" Laplacian光顺")]),t._v(" "),a("p",[t._v("我们在进行网格光顺时并没有考虑权重对新坐标的影响，如果引入权重光顺的效果会更好一些。这里只是浅显地实验一下")]),t._v(" "),a("p",[a("img",{attrs:{src:e(429),alt:"image-20220314203137213"}})]),t._v(" "),a("p",[t._v("光顺过程中不能直接用新的顶点去替换别的顶点，因为可能还有别的顶点要使用这个顶点来计算。")]),t._v(" "),a("p",[t._v("容易出错的一处地方是不要忘记将旧顶点的face序号存入新顶点中，否则只能进行一次Laplacian光顺，第二次光顺时就会因为找不到face序号而无法计算。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//计算拉普拉斯算子进行网格光顺后的点\nvoid objLoader::LaplacianCal() {\n\tfor (int i = 0; i < vset.size(); i++) {\n\t\t//找到顶点周围的所有点的序号\n\t\tvector<GLint> v_near;//存放周围点的序号\n\t\t\n\t\tfor (int j = 3; j < vset[i].size(); j++) {\n\t\t\t//遍历包含该顶点的所有face\n\t\t\t//因为vset存储的是double，得到序号需要转换成int\n\t\t\t//vset[012]存放顶点，之后存放的是face的索引(从0开始）\n\t\t\tint faceindex = (int)vset[i][j];\n\t\t\tfor (int k = 0; k < 5; k = k+2) {//遍历face的三个顶点索引，注意fset  { v0 , vn0 , v1 , vn1 , v2 , vn2 }\n\t\t\t\t//检查是否与当前顶点是一个顶点，face中存储的序号从1开始\n\t\t\t\tif (fset[faceindex][k]-1!=i ) {\n\t\t\t\t\t//不是的话加入v_near\n\t\t\t\t\tv_near.push_back(fset[faceindex][k]-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//计算拉普拉斯分量乘以参数\n\t\tdouble xsum = 0, \n\t\t\t\tysum = 0,\n\t\t\t\tzsum = 0;\n\t\tfor (int m = 0; m < v_near.size(); m++) {\n\t\t\tint vindex = v_near[m];\n\t\t\txsum += vset[vindex][0];\n\t\t\tysum += vset[vindex][1];\n\t\t\tzsum += vset[vindex][2];\n\t\t}\n\t\tint numofv = v_near.size();\n\t\tdouble newx = xsum / numofv*para_ofLaplacian + (1-para_ofLaplacian)*vset[i][0],\n\t\t\tnewy = ysum / numofv * para_ofLaplacian + (1 - para_ofLaplacian)*vset[i][1],\n\t\t\tnewz = zsum / numofv * para_ofLaplacian + (1 - para_ofLaplacian)*vset[i][2];\n\t\tvector<GLdouble> newv;\n\t\tnewv.push_back(newx);\n\t\tnewv.push_back(newy);\n\t\tnewv.push_back(newz);\n\t\tfor (int n = 3; n < vset[i].size(); n++) newv.push_back(vset[i][n]);//不要忘记将face序号也存储进去，准备下一次拉普拉斯算子的计算\n\t\t//存储新顶点\n\t\tvset_afterLaplacian.push_back(newv);\n\t\t\n\t}\n\tvset.clear();\n\tvset.assign(vset_afterLaplacian.begin(), vset_afterLaplacian.end());\n\tvset_afterLaplacian.clear();\n}\n")])])]),a("p",[t._v("看一下Laplacian算子进行光顺之后的效果（左为原模型，右为Laplacian系数设置为0.5，光顺3次之后的结果）")]),t._v(" "),a("p",[a("img",{attrs:{src:e(430),alt:"image-20220314203211953"}})]),t._v(" "),a("p",[a("img",{attrs:{src:e(431),alt:"image-20220314203222898"}})]),t._v(" "),a("h2",{attrs:{id:"demo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#demo"}},[t._v("#")]),t._v(" Demo")]),t._v(" "),a("p",[t._v("Demo还实现了使用鼠标左键拖拽，右键旋转、滚轮缩放的功能，支持绘制模式在GL_LINE和GL_FILL之间切换，反转顶点法向。交互做的比较糙，虽然拖拽只能在XOZ平面上拖拽，旋转只能绕Z轴和Y轴旋转，但结合起来基本上模型哪个部分都能看到（可能旋转之后有些别扭就是了），关于使用main文件里面有说明")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://download.csdn.net/download/vikanill/11215197",target:"_blank",rel:"noopener noreferrer"}},[t._v("openGL使用Laplacian算子进行网格光顺"),a("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=v.exports}}]);