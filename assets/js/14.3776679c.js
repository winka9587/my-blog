(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{511:function(i,n){i.exports="data:image/png;base64,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"},512:function(i,n,t){i.exports=t.p+"assets/img/20200604175220893.63cc2b53.png"},513:function(i,n,t){i.exports=t.p+"assets/img/20200604175900733.8c2c29d2.jpg"},514:function(i,n,t){i.exports=t.p+"assets/img/20200604185956228.10d06599.jpg"},515:function(i,n,t){i.exports=t.p+"assets/img/20200604181544446.a15071d2.png"},582:function(i,n,t){"use strict";t.r(n);var a=t(56),l=Object(a.a)({},(function(){var i=this,n=i.$createElement,a=i._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[a("h1",{attrs:{id:"基于svm的划线框识别-2-roc曲线-二分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于svm的划线框识别-2-roc曲线-二分类"}},[i._v("#")]),i._v(" 基于SVM的划线框识别（2）ROC曲线（二分类）")]),i._v(" "),a("p",[i._v("SVM做到最后用准确率画个ROC曲线。直接写了一套函数，也方便比较不同模型哪个更好一些。")]),i._v(" "),a("h2",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[i._v("#")]),i._v(" 概念")]),i._v(" "),a("p",[i._v("ROC曲线横坐标为假阳性率/假正例率/误报率FPR（False Positive Rate），纵坐标为真阳性率/真正例率/正样本率TPR（True Positive Rate）。")]),i._v(" "),a("p",[a("img",{attrs:{src:t(511),alt:"img"}}),i._v(" 实际的样本分类")]),i._v(" "),a("p",[a("img",{attrs:{src:t(512),alt:"img"}}),i._v(" 模型对样本进行的分类")]),i._v(" "),a("p",[i._v("模型在对样本进行预测之后，一般来说分类的正确率是无法达到100%。由此我们就能得到：")]),i._v(" "),a("p",[a("img",{attrs:{src:t(513),alt:"img"}}),a("img",{attrs:{src:"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==",alt:"点击并拖拽以移动"}})]),i._v(" "),a("p",[i._v("一个样本通过“实际是哪一类”和“被模型分类到哪一类”这两个属性可以确定其属于TP、FN、FP还是TN。而所谓TPR（True Positive Rate）也就是TP（True Positive）在P（Positive)中所占的比例（Rate）。"),a("strong",[i._v("注意P指的是实际正样本的个数，即P = TP + FN。真正例率：在预测为“真的”的一群样本中，其中预测正确的概率。")])]),i._v(" "),a("p",[i._v("FPR = FP/N，这里的N（Negative）指的是实际负样本的个数。"),a("strong",[i._v("误报率")]),i._v("这个名字可能好理解一些，"),a("strong",[i._v("原本是“假的”却被判断成“真的”的概率。")])]),i._v(" "),a("p",[i._v("刚接触这些很容易混淆，假设实际样本的“正负”表示的是警察局接到的报警电话是真的还是假的，预测的样本正负指代接线员判断这个报警电话是真是假，并由此来决定警察是否出警。那么TPR就是警察正确判断真的报警电话并出警的次数/总计真的报警电话的数量。也就是说TPR的值越高，说明警察正确判断越多，接线员的判断越准确，工作更有效。而FPR则是接线员判断错误，警察白费力气出警的次数/假的报警电话的数量，也就是说FPR的值越大，警察做的无用功越多，接线员判断的越不准确。")]),i._v(" "),a("p",[i._v("也就是说，我们追求的模型应该具有低FPR和高TPR，也就是接近左上角的位置")]),i._v(" "),a("h2",{attrs:{id:"具体操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具体操作"}},[i._v("#")]),i._v(" 具体操作")]),i._v(" "),a("p",[i._v("因为ROC曲线的作用是来比较不同模型的训练效果，越接近左上角，曲线积分面积越大，分类的效果也就越好。")]),i._v(" "),a("p",[i._v("下面以五个样本为例说明如何将n个样本映射成n个ROC曲线上的点：")]),i._v(" "),a("p",[i._v("假设有5个样本，它们的实际类标签分别为[-1，-1，1，1，1]，它们的决策值分别为[0.3,0.4,0.5,0.6,0.7]。")]),i._v(" "),a("p",[i._v("第一次选择0.3作为阈值，小于等于0.3的分类为-1，大于0.3的分类为1。分类后的类别标签为[-1,1,1,1,1]，（得到预测后的类别标签与实际的类标签就能得到FP和TP了，也就意味着可以根据分类后的类别标签和实际的类别标签来计算TPR和FPR了）")]),i._v(" "),a("p",[i._v("判断正确的正样本数量为3，实际的正样本数量为3。判断错误的负样本数量为1，实际的负样本数量为2")]),i._v(" "),a("p",[i._v("FPR=1/2=0.5，TPR=3/3=1")]),i._v(" "),a("p",[i._v("第二次选择0.4作为阈值，分类后的标签为[-1，-1，1，1，1]，判断正确的正样本数量为3，判断错误的负样本数量为0。")]),i._v(" "),a("p",[i._v("FPR=0，TPR=3/3=1。")]),i._v(" "),a("p",[i._v("第三次选择0.5为阈值，分类后标签为[-1，-1，-1，1，1] ，判断正确的正样本数量为2，判断错误的负样本数量为0。")]),i._v(" "),a("p",[i._v("FPR=0，TPR=2/3=0.67。")]),i._v(" "),a("p",[i._v("第四次选择0.5为阈值，分类后标签为[-1，-1，-1，-1，1] ，判断正确的正样本数量为1，判断错误的负样本数量为0。")]),i._v(" "),a("p",[i._v("FPR=0，TPR=1/3=0.33。")]),i._v(" "),a("p",[i._v("第五次选择0.5为阈值，分类后标签为[-1，-1，-1，-1，-1] ，判断正确的正样本数量为0，判断错误的负样本数量为0。")]),i._v(" "),a("p",[i._v("FPR=0，TPR=0。")]),i._v(" "),a("p",[i._v("于是由5个样本获得了5个ROC的坐标(0.5,1),(0,1),(0,0.67),(0,0.33),(0,0)。由这5个坐标绘制出该模型的ROC曲线。")]),i._v(" "),a("p",[i._v("y=x即TPR = FPR，如果ROC曲线y=x附近，说明这个模型分类的效果非常差（五五开）。通常会使用AUC值来辅助ROC曲线，AUC计算的是曲线下方的面积大小，也就意味着AUC值越大，ROC曲线越接近左上角(0,1)，分类的效果也就越好，因为不同模型对同一组数据通常有不同的决策值，也就有不同的ROC曲线，可以用于比较两个不同模型训练效果。不过我都没绘制曲线，AUC也就没算。")]),i._v(" "),a("p",[i._v("绘制ROC曲线时，使用的是一组测试数据，这些数据实际的类别我们是知道的，通过模型对这些数据进行预测之后，我们能得到模型对每个样本的一个决策值，在libsvm中：")]),i._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[i._v("p_label, p_acc, p_val = svm.svm_predict(...)\n")])])]),a("p",[i._v("p_label是模型对样本预测的分类，p_acc是准确率，p_val则是决策值，在绘制ROC曲线时我们要用到p_label和p_val，在模型对数据集预测完之后将其写入到ROC.txt中去，格式像下面这样，每一行对应一个样本，两个数值分别是样本的实际分类和决策值。")]),i._v(" "),a("p",[a("img",{attrs:{src:t(514),alt:"img"}}),a("img",{attrs:{src:"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==",alt:"点击并拖拽以移动"}})]),i._v(" "),a("p",[i._v("然后通过这两个数据，计算出ROC曲线上的坐标。将ROC.txt作为参数file_path传入。通过前面的概念可以知道，ROC曲线上的每一个坐标都是一对（FPR,TPR）。我们每次将一个样本的决策值作为分类的阈值，一旦有了阈值，也就能对所有的样本进行分类，而我们也预先知道每个样本的实际分类。于是就能得到TPR和FPR。将所有数据的决策值都轮流用作一次阈值，n个样本就能得到n个ROC曲线上的坐标。")]),i._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[i._v('#用于ROC坐标的排序\ndef takeFirst(elem):\n    return elem[0]\n\ndef createROC(file_path,save_path):\n    #读取txt文件，将其中的实际label和决策值p_val读取出来\n    label = []\n    p_val = []\n    index = 0\n    #实际正样本数量\n    count_P = 0\n    #实际负样本数量\n    count_N = 0\n    with open(file_path, \'r\') as f:\n        for line in f.readlines():\n                # 去掉末尾换行符\n                line = line.strip()\n                # 每一行为一列的最大值与最小值\n                #l - label和v - val\n                l,v = line.split(" ",1)\n                label.append(float(l))\n                p_val.append(float(v))\n                if (label[index]>0):\n                    count_P += 1\n                else:\n                    count_N += 1\n                index = index + 1\n    #读取完毕，获得了index个样本的标签和决策值\n    #实际正样本数量：count_P，实际负样本数量：count_N\n    #存储TPR和FPR\n    pos = []\n    #然后依次将这些决策值作为阈值\n    for value in p_val:\n        #当前的阈值为value\n        #要根据当前阈值，获得分类正确的正样本数量 TP\n        #分类错误的负样本数量 FP\n        TP = 0\n        FP = 0\n        index = 0\n        #每个决策值依次作为分类的阈值\n        for i in p_val:\n            if(i<=value):\n                label_now = -1.0\n            else:\n                label_now = 1.0\n            #如果是分类正确的正样本\n            if(label_now>0 and label[index]>0):\n                TP += 1\n            #如果是分类错误的负样本\n            if(label_now>0 and label[index]<0):\n                FP += 1\n            #计数增加\n            index += 1\n        #计算FPR和TPR\n        FPR = FP/count_N\n        TPR = TP/count_P\n        pos.append((FPR,TPR))\n    #按横坐标进行排序 (默认升序)，为了之后的绘图（如果使用Matlab的话不需要这一行）\n    pos.sort(key=takeFirst)\n    #写入文件保存起来\n    for x,y in pos:\n        pos_str = str(x) + " " + str(y) + "\\n"\n        #保存\n        get_f.writeindata(save_path, pos_str)\n    return\n')])])]),a("h2",{attrs:{id:"绘制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绘制"}},[i._v("#")]),i._v(" 绘制")]),i._v(" "),a("p",[i._v("有了点的坐标，就可以使用matlab拟合出曲线了，但我当时做到这里偷懒了，为了能快速出结果，同时样本的数量有3000个足够多，就直接用折线来近似曲线了。")]),i._v(" "),a("p",[i._v("注意：绘制折线的时候要将坐标点按横坐标从小到大排序然后依次绘制。")]),i._v(" "),a("p",[a("img",{attrs:{src:t(515),alt:"img"}}),a("img",{attrs:{src:"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==",alt:"点击并拖拽以移动"}})]),i._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[i._v("def drawROC(path):\n    pos_x = []\n    pos_y = []\n    with open(path, 'r') as f:\n        for line in f.readlines():\n                # 去掉末尾换行符\n                line = line.strip()\n                # 每一行为一列的最大值与最小值\n                roc_x,roc_y = line.split(\" \",1)\n                #print(roc_x+\",\"+roc_y)\n                pos_x.append(float(roc_x))\n                pos_y.append(float(roc_y))\n\n    # 绘制ROC曲线\n    # 设置画图窗口大小\n    plt.figure(figsize=(5, 5))\n    # 添加标题\n    plt.title(\"ROC Curve\", fontsize='15')\n    #\n    plt.plot([0,1], [1,1], color='black', ls='--', lw=1, label='top')\n    plt.plot([0, 1], [0, 1], color='blue', ls='--', lw=1, label='TPR=FPR')\n    #绘制ROC\n    plt.plot(pos_x,pos_y,color='red',ls='-',lw=2,label='roc line')\n\n    plt.xlim((-0.01, 1.01))  # 设置x轴最大最小值 偏移了一点是为了让曲线展示得更清晰\n    plt.ylim((0, 1.05))  # 设置y轴最大最小值\n    plt.xlabel('FPR')  # 添加x轴图标\n    plt.ylabel('TPR')  # 添加y轴图标\n    plt.legend()  # 添加图例\n\n    #将图片保存起来\n    plt.savefig('E://data/424/ROC.png')\n    plt.show()\n    return\n")])])])])}),[],!1,null,null,null);n.default=l.exports}}]);